{"version":3,"sources":["DynamicForm.spec.js"],"names":["chance","Chance","randomType","useRowCombination","integer","failTest","wrapper","field","count","state","errors","id","setState","update","expect","childAt","find","InlineErrorComponent","props","text","toEqual","createRandomOptions","options","numberOfOptions","counter","word","generateTestFormJson","name","jsonForm","numberOfFields","fields","type","numberOfSubFields","subFields","subFieldType","subField","validation","placeholder","describe","setRequest","jest","fn","testJson","route","renderComponent","Object","keys","beforeEach","it","Segment","padded","toBeTruthy","header","Header","size","debug","Form","forEach","fail","form","segmentOfFields","label","Checkbox","Radio","TextArea","Dropdown","Group","subFieldCounter","input","rowInput","Input","ifailTest","submitSegment","button","Button"],"mappings":"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","file":"DynamicForm.spec.js","sourcesContent":["import React from 'react';\nimport {\n  Button,\n  Form,\n  Segment,\n  Header,\n  Radio,\n  Checkbox,\n  TextArea,\n  Dropdown,\n  Input,\n} from 'semantic-ui-react';\nimport { shallow } from 'enzyme';\nimport { Chance } from 'chance';\nimport DynamicFormComponent from '../../../src/components/helpers/DynamicForm';\nimport InlineErrorComponent from '../../../src/components/helpers/InlineError';\n\nconst chance = new Chance();\n\nconst randomType = (useRowCombination) => {\n  switch (chance.integer() % 5) {\n    case 0:\n      return 'textArea';\n    case 1:\n      return 'radio';\n    case 2:\n      return 'checkbox';\n    case 3:\n      return 'input';\n    case 4:\n      if (useRowCombination) {\n        return 'rowCombination';\n      }\n      return 'input';\n    default:\n      return 'textArea';\n  }\n};\n\nconst failTest = (wrapper, field, count) => {\n  if (chance.integer() % 2) {\n    const state = { errors: {} };\n    state.errors[field.id] = 'Nothing is Selected';\n    wrapper.setState(state);\n    wrapper.update();\n    expect(\n      wrapper\n        .childAt(1)\n        .childAt(0)\n        .childAt(count)\n        .find(InlineErrorComponent)\n        .props().text,\n    ).toEqual('Nothing is Selected');\n  }\n};\n\nconst createRandomOptions = () => {\n  const options = [];\n  const numberOfOptions = (chance.integer() % 11) + 1;\n  for (let counter = 0; counter < numberOfOptions; counter += 1) {\n    options[counter] = chance.word();\n  }\n  return options;\n};\n\nconst generateTestFormJson = () => {\n  const name = chance.word();\n  const jsonForm = {};\n  const numberOfFields = (chance.integer() % 11) + 1;\n  const fields = [];\n  for (let counter = 0; counter < numberOfFields; counter += 1) {\n    const type = randomType(true);\n\n    let field = {};\n    if (type === 'rowCombination') {\n      const numberOfSubFields = (chance.integer() % 11) + 1;\n      const subFields = [];\n      for (let count = 0; count < numberOfSubFields; count += 1) {\n        const subFieldType = randomType(false);\n        const subField = {\n          name: chance.word(),\n          type: subFieldType,\n          id: chance.word(),\n        };\n\n        if (chance.integer() % 2 === 0) {\n          subField.validation = 'required';\n        }\n\n        if (type === 'radio') {\n          subField.options = createRandomOptions();\n        }\n\n        if (subFieldType === 'textArea' || type === 'input') {\n          subField.placeholder = chance.word();\n        }\n\n        subFields[count] = subField;\n      }\n\n      field = {\n        name: chance.word(),\n        type: 'rowCombination',\n        fields: subFields,\n      };\n    } else {\n      field = {\n        name: chance.word(),\n        type,\n        id: chance.word(),\n      };\n\n      if (chance.integer() % 2 === 0) {\n        field.validation = 'required';\n      }\n      if (type === 'radio') {\n        field.options = createRandomOptions();\n      }\n      if (type === 'textArea' || type === 'input') {\n        field.placeholder = chance.word();\n      }\n    }\n\n\n    fields[counter] = field;\n  }\n  jsonForm[name] = {};\n  jsonForm[name].fields = fields;\n  return jsonForm;\n};\n\ndescribe('DynamicForm', () => {\n  let wrapper;\n  const setRequest = jest.fn();\n  const testJson = generateTestFormJson();\n  const route = jest.fn();\n  const renderComponent = () =>\n    shallow(\n      <DynamicFormComponent\n        jsonForm={() => testJson}\n        setRequest={setRequest}\n        form={Object.keys(testJson)[0]}\n        route={() => {\n          route();\n        }}\n      />,\n    );\n\n  beforeEach(() => {\n    wrapper = renderComponent();\n  });\n\n  it('is wrapped in a Segment', () => {\n    expect(wrapper.type()).toEqual(Segment);\n  });\n\n  it('is styled as a padded Segment', () => {\n    expect(wrapper.props().padded).toBeTruthy();\n  });\n\n  describe('header', () => {\n    let header;\n\n    beforeEach(() => {\n      header = wrapper.childAt(0);\n    });\n\n    it('is a header', () => {\n      expect(header.type()).toEqual(Header);\n    });\n\n    it('is has a large size', () => {\n      expect(header.props().size).toEqual('large');\n    });\n\n    it('is the correct text in the header', () => {\n      expect(header.childAt(0).debug()).toEqual(Object.keys(testJson)[0]);\n    });\n  });\n\n  describe('form', () => {\n    it('is a form', () => {\n      expect(wrapper.childAt(1).type()).toEqual(Form);\n    });\n\n\n    describe('form data', () => {\n      wrapper = renderComponent();\n      testJson[Object.keys(testJson)[0]].fields.forEach((field) => {\n        if (field.validation) {\n          const fail = chance.integer() % 2;\n          let count = 0;\n          const form = wrapper.childAt(1);\n          const segmentOfFields = form.childAt(0);\n          it(`field ${count} is correct`, () => {\n            const label = segmentOfFields.childAt(count).childAt(0);\n            if (field.validation) {\n              expect(label.text()).toEqual(` * ${field.name}`);\n            } else {\n              expect(label.text()).toEqual(field.name);\n            }\n            expect(\n              wrapper\n                .childAt(1)\n                .childAt(0)\n                .childAt(count)\n                .childAt(1)\n                .props().name === field.name,\n            );\n            if (field.type === 'checkbox') {\n              expect(\n                wrapper\n                  .childAt(1)\n                  .childAt(0)\n                  .childAt(count)\n                  .childAt(1)\n                  .type(),\n              ).toEqual(Checkbox);\n            }\n            if (field.type === 'radio') {\n              expect(\n                wrapper\n                  .childAt(1)\n                  .childAt(0)\n                  .childAt(count)\n                  .childAt(1)\n                  .type(),\n              ).toEqual(Radio);\n              failTest(wrapper, field, count);\n            }\n            if (field.type === 'textArea') {\n              expect(\n                wrapper\n                  .childAt(1)\n                  .childAt(0)\n                  .childAt(count)\n                  .childAt(1)\n                  .type(),\n              ).toEqual(TextArea);\n              failTest(wrapper, field, count);\n            }\n            if (field.type === 'dropDown') {\n              expect(\n                wrapper\n                  .childAt(1)\n                  .childAt(0)\n                  .childAt(count)\n                  .childAt(1)\n                  .type(),\n              ).toEqual(Dropdown);\n              failTest(wrapper, field, count);\n            }\n\n            if (field.type === 'rowCombination') {\n              expect(\n                wrapper\n                  .childAt(1)\n                  .childAt(0)\n                  .childAt(count)\n                  .childAt(1)\n                  .type(),\n              ).toEqual(Form.Group);\n\n              let subFieldCounter = 0;\n              field.fields.forEach((input) => {\n                const rowInput = wrapper\n                  .childAt(1)\n                  .childAt(0)\n                  .childAt(count)\n                  .childAt(1)\n                  .childAt(subFieldCounter);\n\n                switch (input.type) {\n                  case 'input':\n                    expect(rowInput.type()).toEqual(Input);\n                    break;\n                  case 'dropDown':\n                    expect(rowInput.type()).toEqual(Dropdown);\n                    break;\n                  case 'textArea':\n                    expect(rowInput.type()).toEqual(TextArea);\n                    break;\n                  case 'checkbox':\n                    expect(rowInput.type()).toEqual(Checkbox);\n                    break;\n                  case 'radio':\n                    expect(rowInput.type()).toEqual(Checkbox);\n                    break;\n                  default:\n                }\n                ifailTest(wrapper, field, count);\n                subFieldCounter += 1;\n              });\n            }\n\n            if (field.type === 'input') {\n              expect(\n                wrapper\n                  .childAt(1)\n                  .childAt(0)\n                  .childAt(count)\n                  .childAt(1)\n                  .type(),\n              ).toEqual(Input);\n\n              failTest(wrapper, field, count);\n            }\n            count += 1;\n          });\n        }\n      });\n    });\n  });\n\n  describe('Submit Button', () => {\n    let submitSegment;\n\n    beforeEach(() => {\n      submitSegment = wrapper.childAt(1).childAt(1);\n    });\n\n    it('It is a segment', () => {\n      expect(submitSegment.type()).toEqual(Segment);\n    });\n\n    it('There is a button in the segment', () => {\n      const button = submitSegment.childAt(0);\n      expect(button.type()).toEqual(Button);\n    });\n  });\n});\n"]}